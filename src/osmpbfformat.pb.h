// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osmpbfformat.proto

#ifndef PROTOBUF_osmpbfformat_2eproto__INCLUDED
#define PROTOBUF_osmpbfformat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace OSM_PBF_FORMAT {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_osmpbfformat_2eproto();
void protobuf_AssignDesc_osmpbfformat_2eproto();
void protobuf_ShutdownFile_osmpbfformat_2eproto();

class CompressedBlockHeader;
class CompressedBlock;
class FileHeader;
class Block;
class StringList;
class Group;
class SparseNode;
class DenseNode;
class Way;
class Relation;

enum Relation_MemberType {
  Relation_MemberType_node = 0,
  Relation_MemberType_way = 1,
  Relation_MemberType_relation = 2
};
bool Relation_MemberType_IsValid(int value);
const Relation_MemberType Relation_MemberType_MemberType_MIN = Relation_MemberType_node;
const Relation_MemberType Relation_MemberType_MemberType_MAX = Relation_MemberType_relation;
const int Relation_MemberType_MemberType_ARRAYSIZE = Relation_MemberType_MemberType_MAX + 1;

// ===================================================================

class CompressedBlockHeader : public ::google::protobuf::MessageLite {
 public:
  CompressedBlockHeader();
  virtual ~CompressedBlockHeader();

  CompressedBlockHeader(const CompressedBlockHeader& from);

  inline CompressedBlockHeader& operator=(const CompressedBlockHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const CompressedBlockHeader& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CompressedBlockHeader* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CompressedBlockHeader* other);

  // implements Message ----------------------------------------------

  CompressedBlockHeader* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CompressedBlockHeader& from);
  void MergeFrom(const CompressedBlockHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string block_type = 1;
  inline bool has_block_type() const;
  inline void clear_block_type();
  static const int kBlockTypeFieldNumber = 1;
  inline const ::std::string& block_type() const;
  inline void set_block_type(const ::std::string& value);
  inline void set_block_type(const char* value);
  inline void set_block_type(const char* value, size_t size);
  inline ::std::string* mutable_block_type();
  inline ::std::string* release_block_type();
  inline void set_allocated_block_type(::std::string* block_type);

  // required int32 block_size = 3;
  inline bool has_block_size() const;
  inline void clear_block_size();
  static const int kBlockSizeFieldNumber = 3;
  inline ::google::protobuf::int32 block_size() const;
  inline void set_block_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:OSM_PBF_FORMAT.CompressedBlockHeader)
 private:
  inline void set_has_block_type();
  inline void clear_has_block_type();
  inline void set_has_block_size();
  inline void clear_has_block_size();

  ::std::string* block_type_;
  ::google::protobuf::int32 block_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmpbfformat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmpbfformat_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmpbfformat_2eproto();
  friend void protobuf_ShutdownFile_osmpbfformat_2eproto();

  void InitAsDefaultInstance();
  static CompressedBlockHeader* default_instance_;
};
// -------------------------------------------------------------------

class CompressedBlock : public ::google::protobuf::MessageLite {
 public:
  CompressedBlock();
  virtual ~CompressedBlock();

  CompressedBlock(const CompressedBlock& from);

  inline CompressedBlock& operator=(const CompressedBlock& from) {
    CopyFrom(from);
    return *this;
  }

  static const CompressedBlock& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CompressedBlock* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CompressedBlock* other);

  // implements Message ----------------------------------------------

  CompressedBlock* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CompressedBlock& from);
  void MergeFrom(const CompressedBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uncompressed_data_size = 2;
  inline bool has_uncompressed_data_size() const;
  inline void clear_uncompressed_data_size();
  static const int kUncompressedDataSizeFieldNumber = 2;
  inline ::google::protobuf::int32 uncompressed_data_size() const;
  inline void set_uncompressed_data_size(::google::protobuf::int32 value);

  // optional bytes uncompressed_data = 1;
  inline bool has_uncompressed_data() const;
  inline void clear_uncompressed_data();
  static const int kUncompressedDataFieldNumber = 1;
  inline const ::std::string& uncompressed_data() const;
  inline void set_uncompressed_data(const ::std::string& value);
  inline void set_uncompressed_data(const char* value);
  inline void set_uncompressed_data(const void* value, size_t size);
  inline ::std::string* mutable_uncompressed_data();
  inline ::std::string* release_uncompressed_data();
  inline void set_allocated_uncompressed_data(::std::string* uncompressed_data);

  // optional bytes zlib_compressed_data = 3;
  inline bool has_zlib_compressed_data() const;
  inline void clear_zlib_compressed_data();
  static const int kZlibCompressedDataFieldNumber = 3;
  inline const ::std::string& zlib_compressed_data() const;
  inline void set_zlib_compressed_data(const ::std::string& value);
  inline void set_zlib_compressed_data(const char* value);
  inline void set_zlib_compressed_data(const void* value, size_t size);
  inline ::std::string* mutable_zlib_compressed_data();
  inline ::std::string* release_zlib_compressed_data();
  inline void set_allocated_zlib_compressed_data(::std::string* zlib_compressed_data);

  // @@protoc_insertion_point(class_scope:OSM_PBF_FORMAT.CompressedBlock)
 private:
  inline void set_has_uncompressed_data_size();
  inline void clear_has_uncompressed_data_size();
  inline void set_has_uncompressed_data();
  inline void clear_has_uncompressed_data();
  inline void set_has_zlib_compressed_data();
  inline void clear_has_zlib_compressed_data();

  ::std::string* uncompressed_data_;
  ::std::string* zlib_compressed_data_;
  ::google::protobuf::int32 uncompressed_data_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmpbfformat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmpbfformat_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmpbfformat_2eproto();
  friend void protobuf_ShutdownFile_osmpbfformat_2eproto();

  void InitAsDefaultInstance();
  static CompressedBlock* default_instance_;
};
// -------------------------------------------------------------------

class FileHeader : public ::google::protobuf::MessageLite {
 public:
  FileHeader();
  virtual ~FileHeader();

  FileHeader(const FileHeader& from);

  inline FileHeader& operator=(const FileHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const FileHeader& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileHeader* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FileHeader* other);

  // implements Message ----------------------------------------------

  FileHeader* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileHeader& from);
  void MergeFrom(const FileHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string parser_must_support = 4;
  inline int parser_must_support_size() const;
  inline void clear_parser_must_support();
  static const int kParserMustSupportFieldNumber = 4;
  inline const ::std::string& parser_must_support(int index) const;
  inline ::std::string* mutable_parser_must_support(int index);
  inline void set_parser_must_support(int index, const ::std::string& value);
  inline void set_parser_must_support(int index, const char* value);
  inline void set_parser_must_support(int index, const char* value, size_t size);
  inline ::std::string* add_parser_must_support();
  inline void add_parser_must_support(const ::std::string& value);
  inline void add_parser_must_support(const char* value);
  inline void add_parser_must_support(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& parser_must_support() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_parser_must_support();

  // repeated string parse_may_exploit = 5;
  inline int parse_may_exploit_size() const;
  inline void clear_parse_may_exploit();
  static const int kParseMayExploitFieldNumber = 5;
  inline const ::std::string& parse_may_exploit(int index) const;
  inline ::std::string* mutable_parse_may_exploit(int index);
  inline void set_parse_may_exploit(int index, const ::std::string& value);
  inline void set_parse_may_exploit(int index, const char* value);
  inline void set_parse_may_exploit(int index, const char* value, size_t size);
  inline ::std::string* add_parse_may_exploit();
  inline void add_parse_may_exploit(const ::std::string& value);
  inline void add_parse_may_exploit(const char* value);
  inline void add_parse_may_exploit(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& parse_may_exploit() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_parse_may_exploit();

  // @@protoc_insertion_point(class_scope:OSM_PBF_FORMAT.FileHeader)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> parser_must_support_;
  ::google::protobuf::RepeatedPtrField< ::std::string> parse_may_exploit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmpbfformat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmpbfformat_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmpbfformat_2eproto();
  friend void protobuf_ShutdownFile_osmpbfformat_2eproto();

  void InitAsDefaultInstance();
  static FileHeader* default_instance_;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::MessageLite {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  static const Block& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Block* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  Block* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .OSM_PBF_FORMAT.StringList string_list = 1;
  inline bool has_string_list() const;
  inline void clear_string_list();
  static const int kStringListFieldNumber = 1;
  inline const ::OSM_PBF_FORMAT::StringList& string_list() const;
  inline ::OSM_PBF_FORMAT::StringList* mutable_string_list();
  inline ::OSM_PBF_FORMAT::StringList* release_string_list();
  inline void set_allocated_string_list(::OSM_PBF_FORMAT::StringList* string_list);

  // repeated .OSM_PBF_FORMAT.Group group_list = 2;
  inline int group_list_size() const;
  inline void clear_group_list();
  static const int kGroupListFieldNumber = 2;
  inline const ::OSM_PBF_FORMAT::Group& group_list(int index) const;
  inline ::OSM_PBF_FORMAT::Group* mutable_group_list(int index);
  inline ::OSM_PBF_FORMAT::Group* add_group_list();
  inline const ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Group >&
      group_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Group >*
      mutable_group_list();

  // optional int32 latlon_granularity = 17 [default = 100];
  inline bool has_latlon_granularity() const;
  inline void clear_latlon_granularity();
  static const int kLatlonGranularityFieldNumber = 17;
  inline ::google::protobuf::int32 latlon_granularity() const;
  inline void set_latlon_granularity(::google::protobuf::int32 value);

  // optional int64 offset_of_latitude = 19 [default = 0];
  inline bool has_offset_of_latitude() const;
  inline void clear_offset_of_latitude();
  static const int kOffsetOfLatitudeFieldNumber = 19;
  inline ::google::protobuf::int64 offset_of_latitude() const;
  inline void set_offset_of_latitude(::google::protobuf::int64 value);

  // optional int64 offset_of_longitude = 20 [default = 0];
  inline bool has_offset_of_longitude() const;
  inline void clear_offset_of_longitude();
  static const int kOffsetOfLongitudeFieldNumber = 20;
  inline ::google::protobuf::int64 offset_of_longitude() const;
  inline void set_offset_of_longitude(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:OSM_PBF_FORMAT.Block)
 private:
  inline void set_has_string_list();
  inline void clear_has_string_list();
  inline void set_has_latlon_granularity();
  inline void clear_has_latlon_granularity();
  inline void set_has_offset_of_latitude();
  inline void clear_has_offset_of_latitude();
  inline void set_has_offset_of_longitude();
  inline void clear_has_offset_of_longitude();

  ::OSM_PBF_FORMAT::StringList* string_list_;
  ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Group > group_list_;
  ::google::protobuf::int64 offset_of_latitude_;
  ::google::protobuf::int64 offset_of_longitude_;
  ::google::protobuf::int32 latlon_granularity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmpbfformat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmpbfformat_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmpbfformat_2eproto();
  friend void protobuf_ShutdownFile_osmpbfformat_2eproto();

  void InitAsDefaultInstance();
  static Block* default_instance_;
};
// -------------------------------------------------------------------

class StringList : public ::google::protobuf::MessageLite {
 public:
  StringList();
  virtual ~StringList();

  StringList(const StringList& from);

  inline StringList& operator=(const StringList& from) {
    CopyFrom(from);
    return *this;
  }

  static const StringList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StringList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StringList* other);

  // implements Message ----------------------------------------------

  StringList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StringList& from);
  void MergeFrom(const StringList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes string_list = 1;
  inline int string_list_size() const;
  inline void clear_string_list();
  static const int kStringListFieldNumber = 1;
  inline const ::std::string& string_list(int index) const;
  inline ::std::string* mutable_string_list(int index);
  inline void set_string_list(int index, const ::std::string& value);
  inline void set_string_list(int index, const char* value);
  inline void set_string_list(int index, const void* value, size_t size);
  inline ::std::string* add_string_list();
  inline void add_string_list(const ::std::string& value);
  inline void add_string_list(const char* value);
  inline void add_string_list(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& string_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_string_list();

  // @@protoc_insertion_point(class_scope:OSM_PBF_FORMAT.StringList)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> string_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmpbfformat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmpbfformat_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmpbfformat_2eproto();
  friend void protobuf_ShutdownFile_osmpbfformat_2eproto();

  void InitAsDefaultInstance();
  static StringList* default_instance_;
};
// -------------------------------------------------------------------

class Group : public ::google::protobuf::MessageLite {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }

  static const Group& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Group* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Group* other);

  // implements Message ----------------------------------------------

  Group* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OSM_PBF_FORMAT.SparseNode sparse_node_list = 1;
  inline int sparse_node_list_size() const;
  inline void clear_sparse_node_list();
  static const int kSparseNodeListFieldNumber = 1;
  inline const ::OSM_PBF_FORMAT::SparseNode& sparse_node_list(int index) const;
  inline ::OSM_PBF_FORMAT::SparseNode* mutable_sparse_node_list(int index);
  inline ::OSM_PBF_FORMAT::SparseNode* add_sparse_node_list();
  inline const ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::SparseNode >&
      sparse_node_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::SparseNode >*
      mutable_sparse_node_list();

  // optional .OSM_PBF_FORMAT.DenseNode dense_node = 2;
  inline bool has_dense_node() const;
  inline void clear_dense_node();
  static const int kDenseNodeFieldNumber = 2;
  inline const ::OSM_PBF_FORMAT::DenseNode& dense_node() const;
  inline ::OSM_PBF_FORMAT::DenseNode* mutable_dense_node();
  inline ::OSM_PBF_FORMAT::DenseNode* release_dense_node();
  inline void set_allocated_dense_node(::OSM_PBF_FORMAT::DenseNode* dense_node);

  // repeated .OSM_PBF_FORMAT.Way way_list = 3;
  inline int way_list_size() const;
  inline void clear_way_list();
  static const int kWayListFieldNumber = 3;
  inline const ::OSM_PBF_FORMAT::Way& way_list(int index) const;
  inline ::OSM_PBF_FORMAT::Way* mutable_way_list(int index);
  inline ::OSM_PBF_FORMAT::Way* add_way_list();
  inline const ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Way >&
      way_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Way >*
      mutable_way_list();

  // repeated .OSM_PBF_FORMAT.Relation relation_list = 4;
  inline int relation_list_size() const;
  inline void clear_relation_list();
  static const int kRelationListFieldNumber = 4;
  inline const ::OSM_PBF_FORMAT::Relation& relation_list(int index) const;
  inline ::OSM_PBF_FORMAT::Relation* mutable_relation_list(int index);
  inline ::OSM_PBF_FORMAT::Relation* add_relation_list();
  inline const ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Relation >&
      relation_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Relation >*
      mutable_relation_list();

  // @@protoc_insertion_point(class_scope:OSM_PBF_FORMAT.Group)
 private:
  inline void set_has_dense_node();
  inline void clear_has_dense_node();

  ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::SparseNode > sparse_node_list_;
  ::OSM_PBF_FORMAT::DenseNode* dense_node_;
  ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Way > way_list_;
  ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Relation > relation_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmpbfformat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmpbfformat_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmpbfformat_2eproto();
  friend void protobuf_ShutdownFile_osmpbfformat_2eproto();

  void InitAsDefaultInstance();
  static Group* default_instance_;
};
// -------------------------------------------------------------------

class SparseNode : public ::google::protobuf::MessageLite {
 public:
  SparseNode();
  virtual ~SparseNode();

  SparseNode(const SparseNode& from);

  inline SparseNode& operator=(const SparseNode& from) {
    CopyFrom(from);
    return *this;
  }

  static const SparseNode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SparseNode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SparseNode* other);

  // implements Message ----------------------------------------------

  SparseNode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SparseNode& from);
  void MergeFrom(const SparseNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint64 osm_node_id = 1;
  inline bool has_osm_node_id() const;
  inline void clear_osm_node_id();
  static const int kOsmNodeIdFieldNumber = 1;
  inline ::google::protobuf::int64 osm_node_id() const;
  inline void set_osm_node_id(::google::protobuf::int64 value);

  // repeated uint32 key = 2 [packed = true];
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 key(int index) const;
  inline void set_key(int index, ::google::protobuf::uint32 value);
  inline void add_key(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      key() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_key();

  // repeated uint32 value = 3 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::uint32 value(int index) const;
  inline void set_value(int index, ::google::protobuf::uint32 value);
  inline void add_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_value();

  // required sint64 latitude = 8;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 8;
  inline ::google::protobuf::int64 latitude() const;
  inline void set_latitude(::google::protobuf::int64 value);

  // required sint64 longitude = 9;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 9;
  inline ::google::protobuf::int64 longitude() const;
  inline void set_longitude(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:OSM_PBF_FORMAT.SparseNode)
 private:
  inline void set_has_osm_node_id();
  inline void clear_has_osm_node_id();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();

  ::google::protobuf::int64 osm_node_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > key_;
  mutable int _key_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > value_;
  mutable int _value_cached_byte_size_;
  ::google::protobuf::int64 latitude_;
  ::google::protobuf::int64 longitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmpbfformat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmpbfformat_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmpbfformat_2eproto();
  friend void protobuf_ShutdownFile_osmpbfformat_2eproto();

  void InitAsDefaultInstance();
  static SparseNode* default_instance_;
};
// -------------------------------------------------------------------

class DenseNode : public ::google::protobuf::MessageLite {
 public:
  DenseNode();
  virtual ~DenseNode();

  DenseNode(const DenseNode& from);

  inline DenseNode& operator=(const DenseNode& from) {
    CopyFrom(from);
    return *this;
  }

  static const DenseNode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DenseNode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DenseNode* other);

  // implements Message ----------------------------------------------

  DenseNode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DenseNode& from);
  void MergeFrom(const DenseNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint64 delta_coded_osm_node_id = 1 [packed = true];
  inline int delta_coded_osm_node_id_size() const;
  inline void clear_delta_coded_osm_node_id();
  static const int kDeltaCodedOsmNodeIdFieldNumber = 1;
  inline ::google::protobuf::int64 delta_coded_osm_node_id(int index) const;
  inline void set_delta_coded_osm_node_id(int index, ::google::protobuf::int64 value);
  inline void add_delta_coded_osm_node_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      delta_coded_osm_node_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_delta_coded_osm_node_id();

  // repeated sint64 delta_coded_latitude = 8 [packed = true];
  inline int delta_coded_latitude_size() const;
  inline void clear_delta_coded_latitude();
  static const int kDeltaCodedLatitudeFieldNumber = 8;
  inline ::google::protobuf::int64 delta_coded_latitude(int index) const;
  inline void set_delta_coded_latitude(int index, ::google::protobuf::int64 value);
  inline void add_delta_coded_latitude(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      delta_coded_latitude() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_delta_coded_latitude();

  // repeated sint64 delta_coded_longitude = 9 [packed = true];
  inline int delta_coded_longitude_size() const;
  inline void clear_delta_coded_longitude();
  static const int kDeltaCodedLongitudeFieldNumber = 9;
  inline ::google::protobuf::int64 delta_coded_longitude(int index) const;
  inline void set_delta_coded_longitude(int index, ::google::protobuf::int64 value);
  inline void add_delta_coded_longitude(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      delta_coded_longitude() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_delta_coded_longitude();

  // repeated int32 key_value_pairs = 10 [packed = true];
  inline int key_value_pairs_size() const;
  inline void clear_key_value_pairs();
  static const int kKeyValuePairsFieldNumber = 10;
  inline ::google::protobuf::int32 key_value_pairs(int index) const;
  inline void set_key_value_pairs(int index, ::google::protobuf::int32 value);
  inline void add_key_value_pairs(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      key_value_pairs() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_key_value_pairs();

  // @@protoc_insertion_point(class_scope:OSM_PBF_FORMAT.DenseNode)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > delta_coded_osm_node_id_;
  mutable int _delta_coded_osm_node_id_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > delta_coded_latitude_;
  mutable int _delta_coded_latitude_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > delta_coded_longitude_;
  mutable int _delta_coded_longitude_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > key_value_pairs_;
  mutable int _key_value_pairs_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmpbfformat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmpbfformat_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmpbfformat_2eproto();
  friend void protobuf_ShutdownFile_osmpbfformat_2eproto();

  void InitAsDefaultInstance();
  static DenseNode* default_instance_;
};
// -------------------------------------------------------------------

class Way : public ::google::protobuf::MessageLite {
 public:
  Way();
  virtual ~Way();

  Way(const Way& from);

  inline Way& operator=(const Way& from) {
    CopyFrom(from);
    return *this;
  }

  static const Way& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Way* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Way* other);

  // implements Message ----------------------------------------------

  Way* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Way& from);
  void MergeFrom(const Way& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 osm_way_id = 1;
  inline bool has_osm_way_id() const;
  inline void clear_osm_way_id();
  static const int kOsmWayIdFieldNumber = 1;
  inline ::google::protobuf::int64 osm_way_id() const;
  inline void set_osm_way_id(::google::protobuf::int64 value);

  // repeated uint32 key = 2 [packed = true];
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 key(int index) const;
  inline void set_key(int index, ::google::protobuf::uint32 value);
  inline void add_key(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      key() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_key();

  // repeated uint32 value = 3 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::uint32 value(int index) const;
  inline void set_value(int index, ::google::protobuf::uint32 value);
  inline void add_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_value();

  // repeated sint64 node_list = 8 [packed = true];
  inline int node_list_size() const;
  inline void clear_node_list();
  static const int kNodeListFieldNumber = 8;
  inline ::google::protobuf::int64 node_list(int index) const;
  inline void set_node_list(int index, ::google::protobuf::int64 value);
  inline void add_node_list(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      node_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_node_list();

  // @@protoc_insertion_point(class_scope:OSM_PBF_FORMAT.Way)
 private:
  inline void set_has_osm_way_id();
  inline void clear_has_osm_way_id();

  ::google::protobuf::int64 osm_way_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > key_;
  mutable int _key_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > value_;
  mutable int _value_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > node_list_;
  mutable int _node_list_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmpbfformat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmpbfformat_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmpbfformat_2eproto();
  friend void protobuf_ShutdownFile_osmpbfformat_2eproto();

  void InitAsDefaultInstance();
  static Way* default_instance_;
};
// -------------------------------------------------------------------

class Relation : public ::google::protobuf::MessageLite {
 public:
  Relation();
  virtual ~Relation();

  Relation(const Relation& from);

  inline Relation& operator=(const Relation& from) {
    CopyFrom(from);
    return *this;
  }

  static const Relation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Relation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Relation* other);

  // implements Message ----------------------------------------------

  Relation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Relation& from);
  void MergeFrom(const Relation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Relation_MemberType MemberType;
  static const MemberType node = Relation_MemberType_node;
  static const MemberType way = Relation_MemberType_way;
  static const MemberType relation = Relation_MemberType_relation;
  static inline bool MemberType_IsValid(int value) {
    return Relation_MemberType_IsValid(value);
  }
  static const MemberType MemberType_MIN =
    Relation_MemberType_MemberType_MIN;
  static const MemberType MemberType_MAX =
    Relation_MemberType_MemberType_MAX;
  static const int MemberType_ARRAYSIZE =
    Relation_MemberType_MemberType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required int64 osm_relation_id = 1;
  inline bool has_osm_relation_id() const;
  inline void clear_osm_relation_id();
  static const int kOsmRelationIdFieldNumber = 1;
  inline ::google::protobuf::int64 osm_relation_id() const;
  inline void set_osm_relation_id(::google::protobuf::int64 value);

  // repeated uint32 key = 2 [packed = true];
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 key(int index) const;
  inline void set_key(int index, ::google::protobuf::uint32 value);
  inline void add_key(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      key() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_key();

  // repeated uint32 value = 3 [packed = true];
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::uint32 value(int index) const;
  inline void set_value(int index, ::google::protobuf::uint32 value);
  inline void add_value(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_value();

  // repeated int32 member_role_id = 8 [packed = true];
  inline int member_role_id_size() const;
  inline void clear_member_role_id();
  static const int kMemberRoleIdFieldNumber = 8;
  inline ::google::protobuf::int32 member_role_id(int index) const;
  inline void set_member_role_id(int index, ::google::protobuf::int32 value);
  inline void add_member_role_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      member_role_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_member_role_id();

  // repeated sint64 delta_coded_member_id_list = 9 [packed = true];
  inline int delta_coded_member_id_list_size() const;
  inline void clear_delta_coded_member_id_list();
  static const int kDeltaCodedMemberIdListFieldNumber = 9;
  inline ::google::protobuf::int64 delta_coded_member_id_list(int index) const;
  inline void set_delta_coded_member_id_list(int index, ::google::protobuf::int64 value);
  inline void add_delta_coded_member_id_list(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      delta_coded_member_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_delta_coded_member_id_list();

  // repeated .OSM_PBF_FORMAT.Relation.MemberType member_type_list = 10 [packed = true];
  inline int member_type_list_size() const;
  inline void clear_member_type_list();
  static const int kMemberTypeListFieldNumber = 10;
  inline ::OSM_PBF_FORMAT::Relation_MemberType member_type_list(int index) const;
  inline void set_member_type_list(int index, ::OSM_PBF_FORMAT::Relation_MemberType value);
  inline void add_member_type_list(::OSM_PBF_FORMAT::Relation_MemberType value);
  inline const ::google::protobuf::RepeatedField<int>& member_type_list() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_member_type_list();

  // @@protoc_insertion_point(class_scope:OSM_PBF_FORMAT.Relation)
 private:
  inline void set_has_osm_relation_id();
  inline void clear_has_osm_relation_id();

  ::google::protobuf::int64 osm_relation_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > key_;
  mutable int _key_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > value_;
  mutable int _value_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > member_role_id_;
  mutable int _member_role_id_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > delta_coded_member_id_list_;
  mutable int _delta_coded_member_id_list_cached_byte_size_;
  ::google::protobuf::RepeatedField<int> member_type_list_;
  mutable int _member_type_list_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_osmpbfformat_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_osmpbfformat_2eproto();
  #endif
  friend void protobuf_AssignDesc_osmpbfformat_2eproto();
  friend void protobuf_ShutdownFile_osmpbfformat_2eproto();

  void InitAsDefaultInstance();
  static Relation* default_instance_;
};
// ===================================================================


// ===================================================================

// CompressedBlockHeader

// required string block_type = 1;
inline bool CompressedBlockHeader::has_block_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompressedBlockHeader::set_has_block_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompressedBlockHeader::clear_has_block_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompressedBlockHeader::clear_block_type() {
  if (block_type_ != &::google::protobuf::internal::kEmptyString) {
    block_type_->clear();
  }
  clear_has_block_type();
}
inline const ::std::string& CompressedBlockHeader::block_type() const {
  return *block_type_;
}
inline void CompressedBlockHeader::set_block_type(const ::std::string& value) {
  set_has_block_type();
  if (block_type_ == &::google::protobuf::internal::kEmptyString) {
    block_type_ = new ::std::string;
  }
  block_type_->assign(value);
}
inline void CompressedBlockHeader::set_block_type(const char* value) {
  set_has_block_type();
  if (block_type_ == &::google::protobuf::internal::kEmptyString) {
    block_type_ = new ::std::string;
  }
  block_type_->assign(value);
}
inline void CompressedBlockHeader::set_block_type(const char* value, size_t size) {
  set_has_block_type();
  if (block_type_ == &::google::protobuf::internal::kEmptyString) {
    block_type_ = new ::std::string;
  }
  block_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompressedBlockHeader::mutable_block_type() {
  set_has_block_type();
  if (block_type_ == &::google::protobuf::internal::kEmptyString) {
    block_type_ = new ::std::string;
  }
  return block_type_;
}
inline ::std::string* CompressedBlockHeader::release_block_type() {
  clear_has_block_type();
  if (block_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = block_type_;
    block_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CompressedBlockHeader::set_allocated_block_type(::std::string* block_type) {
  if (block_type_ != &::google::protobuf::internal::kEmptyString) {
    delete block_type_;
  }
  if (block_type) {
    set_has_block_type();
    block_type_ = block_type;
  } else {
    clear_has_block_type();
    block_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 block_size = 3;
inline bool CompressedBlockHeader::has_block_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompressedBlockHeader::set_has_block_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompressedBlockHeader::clear_has_block_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompressedBlockHeader::clear_block_size() {
  block_size_ = 0;
  clear_has_block_size();
}
inline ::google::protobuf::int32 CompressedBlockHeader::block_size() const {
  return block_size_;
}
inline void CompressedBlockHeader::set_block_size(::google::protobuf::int32 value) {
  set_has_block_size();
  block_size_ = value;
}

// -------------------------------------------------------------------

// CompressedBlock

// required int32 uncompressed_data_size = 2;
inline bool CompressedBlock::has_uncompressed_data_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompressedBlock::set_has_uncompressed_data_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompressedBlock::clear_has_uncompressed_data_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompressedBlock::clear_uncompressed_data_size() {
  uncompressed_data_size_ = 0;
  clear_has_uncompressed_data_size();
}
inline ::google::protobuf::int32 CompressedBlock::uncompressed_data_size() const {
  return uncompressed_data_size_;
}
inline void CompressedBlock::set_uncompressed_data_size(::google::protobuf::int32 value) {
  set_has_uncompressed_data_size();
  uncompressed_data_size_ = value;
}

// optional bytes uncompressed_data = 1;
inline bool CompressedBlock::has_uncompressed_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompressedBlock::set_has_uncompressed_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompressedBlock::clear_has_uncompressed_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompressedBlock::clear_uncompressed_data() {
  if (uncompressed_data_ != &::google::protobuf::internal::kEmptyString) {
    uncompressed_data_->clear();
  }
  clear_has_uncompressed_data();
}
inline const ::std::string& CompressedBlock::uncompressed_data() const {
  return *uncompressed_data_;
}
inline void CompressedBlock::set_uncompressed_data(const ::std::string& value) {
  set_has_uncompressed_data();
  if (uncompressed_data_ == &::google::protobuf::internal::kEmptyString) {
    uncompressed_data_ = new ::std::string;
  }
  uncompressed_data_->assign(value);
}
inline void CompressedBlock::set_uncompressed_data(const char* value) {
  set_has_uncompressed_data();
  if (uncompressed_data_ == &::google::protobuf::internal::kEmptyString) {
    uncompressed_data_ = new ::std::string;
  }
  uncompressed_data_->assign(value);
}
inline void CompressedBlock::set_uncompressed_data(const void* value, size_t size) {
  set_has_uncompressed_data();
  if (uncompressed_data_ == &::google::protobuf::internal::kEmptyString) {
    uncompressed_data_ = new ::std::string;
  }
  uncompressed_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompressedBlock::mutable_uncompressed_data() {
  set_has_uncompressed_data();
  if (uncompressed_data_ == &::google::protobuf::internal::kEmptyString) {
    uncompressed_data_ = new ::std::string;
  }
  return uncompressed_data_;
}
inline ::std::string* CompressedBlock::release_uncompressed_data() {
  clear_has_uncompressed_data();
  if (uncompressed_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uncompressed_data_;
    uncompressed_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CompressedBlock::set_allocated_uncompressed_data(::std::string* uncompressed_data) {
  if (uncompressed_data_ != &::google::protobuf::internal::kEmptyString) {
    delete uncompressed_data_;
  }
  if (uncompressed_data) {
    set_has_uncompressed_data();
    uncompressed_data_ = uncompressed_data;
  } else {
    clear_has_uncompressed_data();
    uncompressed_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes zlib_compressed_data = 3;
inline bool CompressedBlock::has_zlib_compressed_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompressedBlock::set_has_zlib_compressed_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompressedBlock::clear_has_zlib_compressed_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompressedBlock::clear_zlib_compressed_data() {
  if (zlib_compressed_data_ != &::google::protobuf::internal::kEmptyString) {
    zlib_compressed_data_->clear();
  }
  clear_has_zlib_compressed_data();
}
inline const ::std::string& CompressedBlock::zlib_compressed_data() const {
  return *zlib_compressed_data_;
}
inline void CompressedBlock::set_zlib_compressed_data(const ::std::string& value) {
  set_has_zlib_compressed_data();
  if (zlib_compressed_data_ == &::google::protobuf::internal::kEmptyString) {
    zlib_compressed_data_ = new ::std::string;
  }
  zlib_compressed_data_->assign(value);
}
inline void CompressedBlock::set_zlib_compressed_data(const char* value) {
  set_has_zlib_compressed_data();
  if (zlib_compressed_data_ == &::google::protobuf::internal::kEmptyString) {
    zlib_compressed_data_ = new ::std::string;
  }
  zlib_compressed_data_->assign(value);
}
inline void CompressedBlock::set_zlib_compressed_data(const void* value, size_t size) {
  set_has_zlib_compressed_data();
  if (zlib_compressed_data_ == &::google::protobuf::internal::kEmptyString) {
    zlib_compressed_data_ = new ::std::string;
  }
  zlib_compressed_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompressedBlock::mutable_zlib_compressed_data() {
  set_has_zlib_compressed_data();
  if (zlib_compressed_data_ == &::google::protobuf::internal::kEmptyString) {
    zlib_compressed_data_ = new ::std::string;
  }
  return zlib_compressed_data_;
}
inline ::std::string* CompressedBlock::release_zlib_compressed_data() {
  clear_has_zlib_compressed_data();
  if (zlib_compressed_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zlib_compressed_data_;
    zlib_compressed_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CompressedBlock::set_allocated_zlib_compressed_data(::std::string* zlib_compressed_data) {
  if (zlib_compressed_data_ != &::google::protobuf::internal::kEmptyString) {
    delete zlib_compressed_data_;
  }
  if (zlib_compressed_data) {
    set_has_zlib_compressed_data();
    zlib_compressed_data_ = zlib_compressed_data;
  } else {
    clear_has_zlib_compressed_data();
    zlib_compressed_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FileHeader

// repeated string parser_must_support = 4;
inline int FileHeader::parser_must_support_size() const {
  return parser_must_support_.size();
}
inline void FileHeader::clear_parser_must_support() {
  parser_must_support_.Clear();
}
inline const ::std::string& FileHeader::parser_must_support(int index) const {
  return parser_must_support_.Get(index);
}
inline ::std::string* FileHeader::mutable_parser_must_support(int index) {
  return parser_must_support_.Mutable(index);
}
inline void FileHeader::set_parser_must_support(int index, const ::std::string& value) {
  parser_must_support_.Mutable(index)->assign(value);
}
inline void FileHeader::set_parser_must_support(int index, const char* value) {
  parser_must_support_.Mutable(index)->assign(value);
}
inline void FileHeader::set_parser_must_support(int index, const char* value, size_t size) {
  parser_must_support_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileHeader::add_parser_must_support() {
  return parser_must_support_.Add();
}
inline void FileHeader::add_parser_must_support(const ::std::string& value) {
  parser_must_support_.Add()->assign(value);
}
inline void FileHeader::add_parser_must_support(const char* value) {
  parser_must_support_.Add()->assign(value);
}
inline void FileHeader::add_parser_must_support(const char* value, size_t size) {
  parser_must_support_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FileHeader::parser_must_support() const {
  return parser_must_support_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FileHeader::mutable_parser_must_support() {
  return &parser_must_support_;
}

// repeated string parse_may_exploit = 5;
inline int FileHeader::parse_may_exploit_size() const {
  return parse_may_exploit_.size();
}
inline void FileHeader::clear_parse_may_exploit() {
  parse_may_exploit_.Clear();
}
inline const ::std::string& FileHeader::parse_may_exploit(int index) const {
  return parse_may_exploit_.Get(index);
}
inline ::std::string* FileHeader::mutable_parse_may_exploit(int index) {
  return parse_may_exploit_.Mutable(index);
}
inline void FileHeader::set_parse_may_exploit(int index, const ::std::string& value) {
  parse_may_exploit_.Mutable(index)->assign(value);
}
inline void FileHeader::set_parse_may_exploit(int index, const char* value) {
  parse_may_exploit_.Mutable(index)->assign(value);
}
inline void FileHeader::set_parse_may_exploit(int index, const char* value, size_t size) {
  parse_may_exploit_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileHeader::add_parse_may_exploit() {
  return parse_may_exploit_.Add();
}
inline void FileHeader::add_parse_may_exploit(const ::std::string& value) {
  parse_may_exploit_.Add()->assign(value);
}
inline void FileHeader::add_parse_may_exploit(const char* value) {
  parse_may_exploit_.Add()->assign(value);
}
inline void FileHeader::add_parse_may_exploit(const char* value, size_t size) {
  parse_may_exploit_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FileHeader::parse_may_exploit() const {
  return parse_may_exploit_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FileHeader::mutable_parse_may_exploit() {
  return &parse_may_exploit_;
}

// -------------------------------------------------------------------

// Block

// required .OSM_PBF_FORMAT.StringList string_list = 1;
inline bool Block::has_string_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Block::set_has_string_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Block::clear_has_string_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Block::clear_string_list() {
  if (string_list_ != NULL) string_list_->::OSM_PBF_FORMAT::StringList::Clear();
  clear_has_string_list();
}
inline const ::OSM_PBF_FORMAT::StringList& Block::string_list() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return string_list_ != NULL ? *string_list_ : *default_instance().string_list_;
#else
  return string_list_ != NULL ? *string_list_ : *default_instance_->string_list_;
#endif
}
inline ::OSM_PBF_FORMAT::StringList* Block::mutable_string_list() {
  set_has_string_list();
  if (string_list_ == NULL) string_list_ = new ::OSM_PBF_FORMAT::StringList;
  return string_list_;
}
inline ::OSM_PBF_FORMAT::StringList* Block::release_string_list() {
  clear_has_string_list();
  ::OSM_PBF_FORMAT::StringList* temp = string_list_;
  string_list_ = NULL;
  return temp;
}
inline void Block::set_allocated_string_list(::OSM_PBF_FORMAT::StringList* string_list) {
  delete string_list_;
  string_list_ = string_list;
  if (string_list) {
    set_has_string_list();
  } else {
    clear_has_string_list();
  }
}

// repeated .OSM_PBF_FORMAT.Group group_list = 2;
inline int Block::group_list_size() const {
  return group_list_.size();
}
inline void Block::clear_group_list() {
  group_list_.Clear();
}
inline const ::OSM_PBF_FORMAT::Group& Block::group_list(int index) const {
  return group_list_.Get(index);
}
inline ::OSM_PBF_FORMAT::Group* Block::mutable_group_list(int index) {
  return group_list_.Mutable(index);
}
inline ::OSM_PBF_FORMAT::Group* Block::add_group_list() {
  return group_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Group >&
Block::group_list() const {
  return group_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Group >*
Block::mutable_group_list() {
  return &group_list_;
}

// optional int32 latlon_granularity = 17 [default = 100];
inline bool Block::has_latlon_granularity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Block::set_has_latlon_granularity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Block::clear_has_latlon_granularity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Block::clear_latlon_granularity() {
  latlon_granularity_ = 100;
  clear_has_latlon_granularity();
}
inline ::google::protobuf::int32 Block::latlon_granularity() const {
  return latlon_granularity_;
}
inline void Block::set_latlon_granularity(::google::protobuf::int32 value) {
  set_has_latlon_granularity();
  latlon_granularity_ = value;
}

// optional int64 offset_of_latitude = 19 [default = 0];
inline bool Block::has_offset_of_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Block::set_has_offset_of_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Block::clear_has_offset_of_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Block::clear_offset_of_latitude() {
  offset_of_latitude_ = GOOGLE_LONGLONG(0);
  clear_has_offset_of_latitude();
}
inline ::google::protobuf::int64 Block::offset_of_latitude() const {
  return offset_of_latitude_;
}
inline void Block::set_offset_of_latitude(::google::protobuf::int64 value) {
  set_has_offset_of_latitude();
  offset_of_latitude_ = value;
}

// optional int64 offset_of_longitude = 20 [default = 0];
inline bool Block::has_offset_of_longitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Block::set_has_offset_of_longitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Block::clear_has_offset_of_longitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Block::clear_offset_of_longitude() {
  offset_of_longitude_ = GOOGLE_LONGLONG(0);
  clear_has_offset_of_longitude();
}
inline ::google::protobuf::int64 Block::offset_of_longitude() const {
  return offset_of_longitude_;
}
inline void Block::set_offset_of_longitude(::google::protobuf::int64 value) {
  set_has_offset_of_longitude();
  offset_of_longitude_ = value;
}

// -------------------------------------------------------------------

// StringList

// repeated bytes string_list = 1;
inline int StringList::string_list_size() const {
  return string_list_.size();
}
inline void StringList::clear_string_list() {
  string_list_.Clear();
}
inline const ::std::string& StringList::string_list(int index) const {
  return string_list_.Get(index);
}
inline ::std::string* StringList::mutable_string_list(int index) {
  return string_list_.Mutable(index);
}
inline void StringList::set_string_list(int index, const ::std::string& value) {
  string_list_.Mutable(index)->assign(value);
}
inline void StringList::set_string_list(int index, const char* value) {
  string_list_.Mutable(index)->assign(value);
}
inline void StringList::set_string_list(int index, const void* value, size_t size) {
  string_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringList::add_string_list() {
  return string_list_.Add();
}
inline void StringList::add_string_list(const ::std::string& value) {
  string_list_.Add()->assign(value);
}
inline void StringList::add_string_list(const char* value) {
  string_list_.Add()->assign(value);
}
inline void StringList::add_string_list(const void* value, size_t size) {
  string_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringList::string_list() const {
  return string_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringList::mutable_string_list() {
  return &string_list_;
}

// -------------------------------------------------------------------

// Group

// repeated .OSM_PBF_FORMAT.SparseNode sparse_node_list = 1;
inline int Group::sparse_node_list_size() const {
  return sparse_node_list_.size();
}
inline void Group::clear_sparse_node_list() {
  sparse_node_list_.Clear();
}
inline const ::OSM_PBF_FORMAT::SparseNode& Group::sparse_node_list(int index) const {
  return sparse_node_list_.Get(index);
}
inline ::OSM_PBF_FORMAT::SparseNode* Group::mutable_sparse_node_list(int index) {
  return sparse_node_list_.Mutable(index);
}
inline ::OSM_PBF_FORMAT::SparseNode* Group::add_sparse_node_list() {
  return sparse_node_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::SparseNode >&
Group::sparse_node_list() const {
  return sparse_node_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::SparseNode >*
Group::mutable_sparse_node_list() {
  return &sparse_node_list_;
}

// optional .OSM_PBF_FORMAT.DenseNode dense_node = 2;
inline bool Group::has_dense_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Group::set_has_dense_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Group::clear_has_dense_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Group::clear_dense_node() {
  if (dense_node_ != NULL) dense_node_->::OSM_PBF_FORMAT::DenseNode::Clear();
  clear_has_dense_node();
}
inline const ::OSM_PBF_FORMAT::DenseNode& Group::dense_node() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dense_node_ != NULL ? *dense_node_ : *default_instance().dense_node_;
#else
  return dense_node_ != NULL ? *dense_node_ : *default_instance_->dense_node_;
#endif
}
inline ::OSM_PBF_FORMAT::DenseNode* Group::mutable_dense_node() {
  set_has_dense_node();
  if (dense_node_ == NULL) dense_node_ = new ::OSM_PBF_FORMAT::DenseNode;
  return dense_node_;
}
inline ::OSM_PBF_FORMAT::DenseNode* Group::release_dense_node() {
  clear_has_dense_node();
  ::OSM_PBF_FORMAT::DenseNode* temp = dense_node_;
  dense_node_ = NULL;
  return temp;
}
inline void Group::set_allocated_dense_node(::OSM_PBF_FORMAT::DenseNode* dense_node) {
  delete dense_node_;
  dense_node_ = dense_node;
  if (dense_node) {
    set_has_dense_node();
  } else {
    clear_has_dense_node();
  }
}

// repeated .OSM_PBF_FORMAT.Way way_list = 3;
inline int Group::way_list_size() const {
  return way_list_.size();
}
inline void Group::clear_way_list() {
  way_list_.Clear();
}
inline const ::OSM_PBF_FORMAT::Way& Group::way_list(int index) const {
  return way_list_.Get(index);
}
inline ::OSM_PBF_FORMAT::Way* Group::mutable_way_list(int index) {
  return way_list_.Mutable(index);
}
inline ::OSM_PBF_FORMAT::Way* Group::add_way_list() {
  return way_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Way >&
Group::way_list() const {
  return way_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Way >*
Group::mutable_way_list() {
  return &way_list_;
}

// repeated .OSM_PBF_FORMAT.Relation relation_list = 4;
inline int Group::relation_list_size() const {
  return relation_list_.size();
}
inline void Group::clear_relation_list() {
  relation_list_.Clear();
}
inline const ::OSM_PBF_FORMAT::Relation& Group::relation_list(int index) const {
  return relation_list_.Get(index);
}
inline ::OSM_PBF_FORMAT::Relation* Group::mutable_relation_list(int index) {
  return relation_list_.Mutable(index);
}
inline ::OSM_PBF_FORMAT::Relation* Group::add_relation_list() {
  return relation_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Relation >&
Group::relation_list() const {
  return relation_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::OSM_PBF_FORMAT::Relation >*
Group::mutable_relation_list() {
  return &relation_list_;
}

// -------------------------------------------------------------------

// SparseNode

// required sint64 osm_node_id = 1;
inline bool SparseNode::has_osm_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SparseNode::set_has_osm_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SparseNode::clear_has_osm_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SparseNode::clear_osm_node_id() {
  osm_node_id_ = GOOGLE_LONGLONG(0);
  clear_has_osm_node_id();
}
inline ::google::protobuf::int64 SparseNode::osm_node_id() const {
  return osm_node_id_;
}
inline void SparseNode::set_osm_node_id(::google::protobuf::int64 value) {
  set_has_osm_node_id();
  osm_node_id_ = value;
}

// repeated uint32 key = 2 [packed = true];
inline int SparseNode::key_size() const {
  return key_.size();
}
inline void SparseNode::clear_key() {
  key_.Clear();
}
inline ::google::protobuf::uint32 SparseNode::key(int index) const {
  return key_.Get(index);
}
inline void SparseNode::set_key(int index, ::google::protobuf::uint32 value) {
  key_.Set(index, value);
}
inline void SparseNode::add_key(::google::protobuf::uint32 value) {
  key_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SparseNode::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SparseNode::mutable_key() {
  return &key_;
}

// repeated uint32 value = 3 [packed = true];
inline int SparseNode::value_size() const {
  return value_.size();
}
inline void SparseNode::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint32 SparseNode::value(int index) const {
  return value_.Get(index);
}
inline void SparseNode::set_value(int index, ::google::protobuf::uint32 value) {
  value_.Set(index, value);
}
inline void SparseNode::add_value(::google::protobuf::uint32 value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SparseNode::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SparseNode::mutable_value() {
  return &value_;
}

// required sint64 latitude = 8;
inline bool SparseNode::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SparseNode::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SparseNode::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SparseNode::clear_latitude() {
  latitude_ = GOOGLE_LONGLONG(0);
  clear_has_latitude();
}
inline ::google::protobuf::int64 SparseNode::latitude() const {
  return latitude_;
}
inline void SparseNode::set_latitude(::google::protobuf::int64 value) {
  set_has_latitude();
  latitude_ = value;
}

// required sint64 longitude = 9;
inline bool SparseNode::has_longitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SparseNode::set_has_longitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SparseNode::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SparseNode::clear_longitude() {
  longitude_ = GOOGLE_LONGLONG(0);
  clear_has_longitude();
}
inline ::google::protobuf::int64 SparseNode::longitude() const {
  return longitude_;
}
inline void SparseNode::set_longitude(::google::protobuf::int64 value) {
  set_has_longitude();
  longitude_ = value;
}

// -------------------------------------------------------------------

// DenseNode

// repeated sint64 delta_coded_osm_node_id = 1 [packed = true];
inline int DenseNode::delta_coded_osm_node_id_size() const {
  return delta_coded_osm_node_id_.size();
}
inline void DenseNode::clear_delta_coded_osm_node_id() {
  delta_coded_osm_node_id_.Clear();
}
inline ::google::protobuf::int64 DenseNode::delta_coded_osm_node_id(int index) const {
  return delta_coded_osm_node_id_.Get(index);
}
inline void DenseNode::set_delta_coded_osm_node_id(int index, ::google::protobuf::int64 value) {
  delta_coded_osm_node_id_.Set(index, value);
}
inline void DenseNode::add_delta_coded_osm_node_id(::google::protobuf::int64 value) {
  delta_coded_osm_node_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
DenseNode::delta_coded_osm_node_id() const {
  return delta_coded_osm_node_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
DenseNode::mutable_delta_coded_osm_node_id() {
  return &delta_coded_osm_node_id_;
}

// repeated sint64 delta_coded_latitude = 8 [packed = true];
inline int DenseNode::delta_coded_latitude_size() const {
  return delta_coded_latitude_.size();
}
inline void DenseNode::clear_delta_coded_latitude() {
  delta_coded_latitude_.Clear();
}
inline ::google::protobuf::int64 DenseNode::delta_coded_latitude(int index) const {
  return delta_coded_latitude_.Get(index);
}
inline void DenseNode::set_delta_coded_latitude(int index, ::google::protobuf::int64 value) {
  delta_coded_latitude_.Set(index, value);
}
inline void DenseNode::add_delta_coded_latitude(::google::protobuf::int64 value) {
  delta_coded_latitude_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
DenseNode::delta_coded_latitude() const {
  return delta_coded_latitude_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
DenseNode::mutable_delta_coded_latitude() {
  return &delta_coded_latitude_;
}

// repeated sint64 delta_coded_longitude = 9 [packed = true];
inline int DenseNode::delta_coded_longitude_size() const {
  return delta_coded_longitude_.size();
}
inline void DenseNode::clear_delta_coded_longitude() {
  delta_coded_longitude_.Clear();
}
inline ::google::protobuf::int64 DenseNode::delta_coded_longitude(int index) const {
  return delta_coded_longitude_.Get(index);
}
inline void DenseNode::set_delta_coded_longitude(int index, ::google::protobuf::int64 value) {
  delta_coded_longitude_.Set(index, value);
}
inline void DenseNode::add_delta_coded_longitude(::google::protobuf::int64 value) {
  delta_coded_longitude_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
DenseNode::delta_coded_longitude() const {
  return delta_coded_longitude_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
DenseNode::mutable_delta_coded_longitude() {
  return &delta_coded_longitude_;
}

// repeated int32 key_value_pairs = 10 [packed = true];
inline int DenseNode::key_value_pairs_size() const {
  return key_value_pairs_.size();
}
inline void DenseNode::clear_key_value_pairs() {
  key_value_pairs_.Clear();
}
inline ::google::protobuf::int32 DenseNode::key_value_pairs(int index) const {
  return key_value_pairs_.Get(index);
}
inline void DenseNode::set_key_value_pairs(int index, ::google::protobuf::int32 value) {
  key_value_pairs_.Set(index, value);
}
inline void DenseNode::add_key_value_pairs(::google::protobuf::int32 value) {
  key_value_pairs_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DenseNode::key_value_pairs() const {
  return key_value_pairs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DenseNode::mutable_key_value_pairs() {
  return &key_value_pairs_;
}

// -------------------------------------------------------------------

// Way

// required int64 osm_way_id = 1;
inline bool Way::has_osm_way_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Way::set_has_osm_way_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Way::clear_has_osm_way_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Way::clear_osm_way_id() {
  osm_way_id_ = GOOGLE_LONGLONG(0);
  clear_has_osm_way_id();
}
inline ::google::protobuf::int64 Way::osm_way_id() const {
  return osm_way_id_;
}
inline void Way::set_osm_way_id(::google::protobuf::int64 value) {
  set_has_osm_way_id();
  osm_way_id_ = value;
}

// repeated uint32 key = 2 [packed = true];
inline int Way::key_size() const {
  return key_.size();
}
inline void Way::clear_key() {
  key_.Clear();
}
inline ::google::protobuf::uint32 Way::key(int index) const {
  return key_.Get(index);
}
inline void Way::set_key(int index, ::google::protobuf::uint32 value) {
  key_.Set(index, value);
}
inline void Way::add_key(::google::protobuf::uint32 value) {
  key_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Way::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Way::mutable_key() {
  return &key_;
}

// repeated uint32 value = 3 [packed = true];
inline int Way::value_size() const {
  return value_.size();
}
inline void Way::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint32 Way::value(int index) const {
  return value_.Get(index);
}
inline void Way::set_value(int index, ::google::protobuf::uint32 value) {
  value_.Set(index, value);
}
inline void Way::add_value(::google::protobuf::uint32 value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Way::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Way::mutable_value() {
  return &value_;
}

// repeated sint64 node_list = 8 [packed = true];
inline int Way::node_list_size() const {
  return node_list_.size();
}
inline void Way::clear_node_list() {
  node_list_.Clear();
}
inline ::google::protobuf::int64 Way::node_list(int index) const {
  return node_list_.Get(index);
}
inline void Way::set_node_list(int index, ::google::protobuf::int64 value) {
  node_list_.Set(index, value);
}
inline void Way::add_node_list(::google::protobuf::int64 value) {
  node_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Way::node_list() const {
  return node_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Way::mutable_node_list() {
  return &node_list_;
}

// -------------------------------------------------------------------

// Relation

// required int64 osm_relation_id = 1;
inline bool Relation::has_osm_relation_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Relation::set_has_osm_relation_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Relation::clear_has_osm_relation_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Relation::clear_osm_relation_id() {
  osm_relation_id_ = GOOGLE_LONGLONG(0);
  clear_has_osm_relation_id();
}
inline ::google::protobuf::int64 Relation::osm_relation_id() const {
  return osm_relation_id_;
}
inline void Relation::set_osm_relation_id(::google::protobuf::int64 value) {
  set_has_osm_relation_id();
  osm_relation_id_ = value;
}

// repeated uint32 key = 2 [packed = true];
inline int Relation::key_size() const {
  return key_.size();
}
inline void Relation::clear_key() {
  key_.Clear();
}
inline ::google::protobuf::uint32 Relation::key(int index) const {
  return key_.Get(index);
}
inline void Relation::set_key(int index, ::google::protobuf::uint32 value) {
  key_.Set(index, value);
}
inline void Relation::add_key(::google::protobuf::uint32 value) {
  key_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Relation::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Relation::mutable_key() {
  return &key_;
}

// repeated uint32 value = 3 [packed = true];
inline int Relation::value_size() const {
  return value_.size();
}
inline void Relation::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint32 Relation::value(int index) const {
  return value_.Get(index);
}
inline void Relation::set_value(int index, ::google::protobuf::uint32 value) {
  value_.Set(index, value);
}
inline void Relation::add_value(::google::protobuf::uint32 value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Relation::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Relation::mutable_value() {
  return &value_;
}

// repeated int32 member_role_id = 8 [packed = true];
inline int Relation::member_role_id_size() const {
  return member_role_id_.size();
}
inline void Relation::clear_member_role_id() {
  member_role_id_.Clear();
}
inline ::google::protobuf::int32 Relation::member_role_id(int index) const {
  return member_role_id_.Get(index);
}
inline void Relation::set_member_role_id(int index, ::google::protobuf::int32 value) {
  member_role_id_.Set(index, value);
}
inline void Relation::add_member_role_id(::google::protobuf::int32 value) {
  member_role_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Relation::member_role_id() const {
  return member_role_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Relation::mutable_member_role_id() {
  return &member_role_id_;
}

// repeated sint64 delta_coded_member_id_list = 9 [packed = true];
inline int Relation::delta_coded_member_id_list_size() const {
  return delta_coded_member_id_list_.size();
}
inline void Relation::clear_delta_coded_member_id_list() {
  delta_coded_member_id_list_.Clear();
}
inline ::google::protobuf::int64 Relation::delta_coded_member_id_list(int index) const {
  return delta_coded_member_id_list_.Get(index);
}
inline void Relation::set_delta_coded_member_id_list(int index, ::google::protobuf::int64 value) {
  delta_coded_member_id_list_.Set(index, value);
}
inline void Relation::add_delta_coded_member_id_list(::google::protobuf::int64 value) {
  delta_coded_member_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Relation::delta_coded_member_id_list() const {
  return delta_coded_member_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Relation::mutable_delta_coded_member_id_list() {
  return &delta_coded_member_id_list_;
}

// repeated .OSM_PBF_FORMAT.Relation.MemberType member_type_list = 10 [packed = true];
inline int Relation::member_type_list_size() const {
  return member_type_list_.size();
}
inline void Relation::clear_member_type_list() {
  member_type_list_.Clear();
}
inline ::OSM_PBF_FORMAT::Relation_MemberType Relation::member_type_list(int index) const {
  return static_cast< ::OSM_PBF_FORMAT::Relation_MemberType >(member_type_list_.Get(index));
}
inline void Relation::set_member_type_list(int index, ::OSM_PBF_FORMAT::Relation_MemberType value) {
  assert(::OSM_PBF_FORMAT::Relation_MemberType_IsValid(value));
  member_type_list_.Set(index, value);
}
inline void Relation::add_member_type_list(::OSM_PBF_FORMAT::Relation_MemberType value) {
  assert(::OSM_PBF_FORMAT::Relation_MemberType_IsValid(value));
  member_type_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
Relation::member_type_list() const {
  return member_type_list_;
}
inline ::google::protobuf::RepeatedField<int>*
Relation::mutable_member_type_list() {
  return &member_type_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace OSM_PBF_FORMAT

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_osmpbfformat_2eproto__INCLUDED
